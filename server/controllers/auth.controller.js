// Rewrite/server/controllers/auth.controller.js
import asyncHandler from 'express-async-handler';
import { body, param, validationResult } from 'express-validator';
import crypto from 'crypto';
import axios from 'axios'; // For reCAPTCHA verification
import User from '../models/user.model.js';
import generateToken from '../utils/generateToken.js';
import sendEmail from '../utils/sendEmail.js'; // Import email utility
import AppError from '../utils/AppError.js';
import { OAuth2Client } from 'google-auth-library'; // Import Google Auth Library

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

const checkValidation = (req, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        const error = new AppError('Validation failed: ' + errors.array().map(e => e.msg).join(', '), 400);
        next(error);
        return false;
    }
    return true;
};

// ... [Existing login, forgotPassword, resetPassword, getMe, updateUserProfile, etc. functions remain here] ...

// @desc    Register a new user
// @route   POST /api/auth/signup
// @access  Public
const signup = [
    // Assuming validation middleware is defined in routes or here:
    body('username').trim().isLength({ min: 3, max: 30 }).withMessage('Username must be between 3 and 30 characters.'),
    body('email').isEmail().withMessage('Please include a valid email.'),
    body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters.'),
    body('captchaToken').notEmpty().withMessage('CAPTCHA token is required.'),

    asyncHandler(async (req, res, next) => {
        if (!checkValidation(req, next)) return;

        const { username, email, password, captchaToken } = req.body;

        // 1. CAPTCHA Verification (Placeholder)
        if (captchaToken.length < 20) {
             return next(new AppError('CAPTCHA verification failed. Please try again.', 400));
        }

        // 2. Check for existing user
        let user = await User.findOne({ $or: [{ username: username }, { email: email }] });

        if (user) {
            // If user exists but is not verified, attempt to resend the email
            if (!user.isVerified) {
                 try {
                     // The token is generated by the pre-save hook on creation, but if they hit
                     // this unverified state again, we should ensure the token is fresh/exists before sending.
                     if (!user.emailVerificationToken) {
                         user.emailVerificationToken = crypto.randomBytes(32).toString('hex');
                         user.emailVerificationExpires = Date.now() + 48 * 60 * 60 * 1000;
                         await user.save({ validateBeforeSave: false });
                     }

                     const verificationLink = `${process.env.CLIENT_URL}/verify-email/${user.emailVerificationToken}`;
                     await sendEmail({
                        email: user.email,
                        subject: 'Rewrite: Please Verify Your Email Address',
                        html: `<p>Welcome to Rewrite! Please click the link below to verify your email address and activate your account:</p><p><a href="${verificationLink}">${verificationLink}</a></p><p>This link will expire in 48 hours.</p>`,
                        message: `Welcome to Rewrite! Please use this link to verify your email: ${verificationLink}`
                     });
                     return res.status(200).json({ 
                        message: 'Account with this email/username already exists but is unverified. Verification email resent.',
                        userExists: true 
                     });
                 } catch (err) {
                     console.error("Error resending verification email:", err);
                     return next(new AppError('Account exists but email verification failed to resend.', 500));
                 }
            } else {
                 return next(new AppError('User with this email or username already exists and is verified.', 400));
            }
        }
        
        // 3. Create new user (pre-save hook hashes password and generates token)
        user = await User.create({
            username,
            email,
            password,
            isVerified: false, // Explicitly set, though default is false
        });

        // 4. Send verification email
        try {
            const verificationLink = `${process.env.CLIENT_URL}/verify-email/${user.emailVerificationToken}`;
            
            await sendEmail({
                email: user.email,
                subject: 'Rewrite: Please Verify Your Email Address',
                html: `<p>Welcome to Rewrite! Please click the link below to verify your email address and activate your account:</p><p><a href="${verificationLink}" style="padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px; display: inline-block;">Verify Email</a></p><p>Or paste this link into your browser: ${verificationLink}</p><p>This link will expire in 48 hours.</p>`,
                message: `Welcome to Rewrite! Please use this link to verify your email: ${verificationLink}`
            });

            res.status(201).json({
                message: 'Registration successful! A verification link has been sent to your email. Please verify to log in.',
                success: true
            });
        } catch (err) {
            // Critical error: If email fails, delete the user to prevent a dangling unverified account
            await User.deleteOne({ _id: user._id }); 
            console.error("Error sending verification email and cleaning user:", err);
            return next(new AppError('Registration failed: Could not send verification email. Account deleted. Please try again.', 500));
        }
    })
];


// @desc    Verify a user's email address
// @route   GET /api/auth/verify-email/:token
// @access  Public
const verifyEmail = [
    param('token').isLength({ min: 64, max: 64 }).withMessage('Invalid token format.'),

    asyncHandler(async (req, res, next) => {
        if (!checkValidation(req, next)) return;

        const { token } = req.params;

        // 1. Find user by token, check expiration date
        const user = await User.findOne({
            emailVerificationToken: token,
            emailVerificationExpires: { $gt: Date.now() } // $gt means greater than (not expired)
        });

        if (!user) {
            return next(new AppError('Verification link is invalid or has expired.', 400));
        }

        // 2. Mark user as verified and clear token fields
        user.isVerified = true;
        user.emailVerificationToken = undefined;
        user.emailVerificationExpires = undefined;

        await user.save({ validateBeforeSave: false });

        // 3. Generate JWT and log the user in immediately
        generateToken(res, user._id);
        
        res.status(200).json({
            message: 'Email successfully verified! You are now logged in.',
            success: true,
            user: {
                id: user._id,
                username: user.username,
                email: user.email,
                isVerified: user.isVerified
            }
        });
    })
];

const googleLogin = asyncHandler(async (req, res, next) => {
    const { token } = req.body;
    
    // 1. Verify Google Token
    const ticket = await client.verifyIdToken({
        idToken: token,
        audience: process.env.GOOGLE_CLIENT_ID,
    });
    const { name, email, picture, sub: googleId } = ticket.getPayload();

    // 2. Check if user exists
    let user = await User.findOne({ email });

    if (user) {
        // User exists
        if (!user.googleId) {
            // Link Google account to existing account
            user.googleId = googleId;
            // If they registered locally but verified via Google now, mark verified
            if(!user.isVerified) user.isVerified = true; 
            if(!user.isEmailVerified) user.isEmailVerified = true;
            await user.save({ validateBeforeSave: false });
        }
    } else {
        // 3. Create new user
        // Generate unique username based on name or email
        const baseName = name ? name.replace(/\s+/g, '_').toLowerCase() : email.split('@')[0];
        const randomSuffix = Math.floor(1000 + Math.random() * 9000);
        let username = `${baseName}_${randomSuffix}`.replace(/[^a-zA-Z0-9_]/g, '');

        // Ensure uniqueness loop (simple check)
        const usernameExists = await User.findOne({ username });
        if (usernameExists) username += `_${Date.now().toString().slice(-4)}`;

        user = await User.create({
            username,
            email,
            password: crypto.randomBytes(20).toString('hex'), // Dummy password for validation
            authProvider: 'google',
            googleId: googleId,
            profilePicture: picture,
            isVerified: true, // Google accounts are verified
            isEmailVerified: true,
            agreedToTerms: true // Implied
        });
    }

    if (user.status === 'deleted') return next(new AppError('Account is deleted.', 401));

    // 4. Return Token
    res.json({
        id: user.id,
        username: user.username,
        role: user.role,
        isVerified: user.isVerified,
        isPrivate: user.isPrivate,
        createdAt: user.createdAt,
        token: generateToken(user.id, user.role),
        profilePicture: user.profilePicture
    });
});

export { registerUser, verifyEmail, loginUser, resetPassword, getUserProfile, googleLogin  };
